package openai

import (
	"context"
	"encoding/json"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNewService(t *testing.T) {
	apiKey := "test-api-key"
	service := NewService(apiKey)

	assert.NotNil(t, service)
	assert.NotNil(t, service.client)
}

func TestLoadPlaylistFromFile_Success(t *testing.T) {
	// Create a temporary test file
	content := `# Test playlist
Metallica - Master of Puppets
Iron Maiden: Run to the Hills
Enter Sandman by Metallica
Just a Song Title

// Another comment
AC/DC - Thunderstruck`

	tmpFile := createTempFile(t, "test-playlist.txt", content)
	defer os.Remove(tmpFile)

	service := NewService("test-key")

	result, err := service.LoadPlaylistFromFile(tmpFile, "My Test Playlist")

	require.NoError(t, err)
	assert.Equal(t, "My Test Playlist", result.PlaylistName)
	assert.Contains(t, result.Description, "test-playlist.txt")
	assert.Contains(t, result.Description, "5 songs")
	assert.Len(t, result.Songs, 5)

	// Test different song formats
	songs := result.Songs

	// "Artist - Song Title"
	assert.Equal(t, "Metallica", songs[0].Artist)
	assert.Equal(t, "Master of Puppets", songs[0].Title)

	// "Artist: Song Title"
	assert.Equal(t, "Iron Maiden", songs[1].Artist)
	assert.Equal(t, "Run to the Hills", songs[1].Title)

	// "Song Title by Artist"
	assert.Equal(t, "Metallica", songs[2].Artist)
	assert.Equal(t, "Enter Sandman", songs[2].Title)

	// Just song title
	assert.Equal(t, "Unknown", songs[3].Artist)
	assert.Equal(t, "Just a Song Title", songs[3].Title)

	// Another "Artist - Song Title"
	assert.Equal(t, "AC/DC", songs[4].Artist)
	assert.Equal(t, "Thunderstruck", songs[4].Title)

	// Check reasons contain file path and line numbers
	for _, song := range songs {
		assert.Contains(t, song.Reason, "test-playlist.txt")
		assert.Contains(t, song.Reason, "line")
	}
}

func TestLoadPlaylistFromFile_AutoGeneratedName(t *testing.T) {
	content := `Metallica - Master of Puppets
Iron Maiden - Run to the Hills`

	tmpFile := createTempFile(t, "metal-songs.txt", content)
	defer os.Remove(tmpFile)

	service := NewService("test-key")

	result, err := service.LoadPlaylistFromFile(tmpFile, "")

	require.NoError(t, err)
	assert.Contains(t, result.PlaylistName, "Metal Songs")
	// Should contain current year (2024 or 2025)
	assert.True(t, strings.Contains(result.PlaylistName, "2024") || strings.Contains(result.PlaylistName, "2025"))
}

func TestLoadPlaylistFromFile_FileNotFound(t *testing.T) {
	service := NewService("test-key")

	result, err := service.LoadPlaylistFromFile("nonexistent.txt", "Test")

	assert.Nil(t, result)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to open file")
}

func TestLoadPlaylistFromFile_EmptyFile(t *testing.T) {
	content := `# Only comments
// Nothing else`

	tmpFile := createTempFile(t, "empty.txt", content)
	defer os.Remove(tmpFile)

	service := NewService("test-key")

	result, err := service.LoadPlaylistFromFile(tmpFile, "Test")

	assert.Nil(t, result)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "no songs found")
}

func TestLoadPlaylistFromFile_DifferentFormats(t *testing.T) {
	tests := []struct {
		name           string
		line           string
		expectedArtist string
		expectedTitle  string
	}{
		{
			name:           "dash format",
			line:           "The Beatles - Hey Jude",
			expectedArtist: "The Beatles",
			expectedTitle:  "Hey Jude",
		},
		{
			name:           "colon format",
			line:           "Queen: Bohemian Rhapsody",
			expectedArtist: "Queen",
			expectedTitle:  "Bohemian Rhapsody",
		},
		{
			name:           "by format",
			line:           "Stairway to Heaven by Led Zeppelin",
			expectedArtist: "Led Zeppelin",
			expectedTitle:  "Stairway to Heaven",
		},
		{
			name:           "title only",
			line:           "Hotel California",
			expectedArtist: "Unknown",
			expectedTitle:  "Hotel California",
		},
		{
			name:           "with extra spaces",
			line:           "  Pink Floyd   -   Comfortably Numb  ",
			expectedArtist: "Pink Floyd",
			expectedTitle:  "Comfortably Numb",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tmpFile := createTempFile(t, "test.txt", tt.line)
			defer os.Remove(tmpFile)

			service := NewService("test-key")
			result, err := service.LoadPlaylistFromFile(tmpFile, "Test")

			require.NoError(t, err)
			require.Len(t, result.Songs, 1)

			song := result.Songs[0]
			assert.Equal(t, tt.expectedArtist, song.Artist)
			assert.Equal(t, tt.expectedTitle, song.Title)
		})
	}
}

func TestGeneratePlaylistFromMultiplePrompts_SinglePrompt(t *testing.T) {
	service := NewService("test-key")

	// This will fail with actual API call, but we can test the logic
	prompts := []string{"rock music"}

	result, err := service.GeneratePlaylistFromMultiplePrompts(context.Background(), prompts, 10)

	// We expect this to fail since we don't have a real API key
	// but we can verify it's calling the right method
	assert.Error(t, err)
	assert.Nil(t, result)
}

func TestGeneratePlaylistFromMultiplePrompts_NoPrompts(t *testing.T) {
	service := NewService("test-key")

	result, err := service.GeneratePlaylistFromMultiplePrompts(context.Background(), []string{}, 10)

	assert.Nil(t, result)
	assert.EqualError(t, err, "no prompts provided")
}

func TestGeneratePlaylistFromMultiplePrompts_MultiplePrompts(t *testing.T) {
	service := NewService("test-key")

	prompts := []string{"rock music", "80s hits", "guitar solos"}

	result, err := service.GeneratePlaylistFromMultiplePrompts(context.Background(), prompts, 15)

	// We expect this to fail since we don't have a real API key
	// but we can verify the prompts are combined
	assert.Error(t, err)
	assert.Nil(t, result)
}

func TestPlaylistResponse_JSONSerialization(t *testing.T) {
	// Test that our structs can be properly marshaled/unmarshaled
	originalResponse := &PlaylistResponse{
		PlaylistName: "Test Playlist",
		Description:  "A test playlist",
		Songs: []Song{
			{
				Artist: "Test Artist",
				Title:  "Test Song",
				Album:  "Test Album",
				Year:   2023,
				Reason: "Test reason",
			},
		},
	}

	// Marshal to JSON
	jsonData, err := json.Marshal(originalResponse)
	require.NoError(t, err)

	// Unmarshal back
	var parsedResponse PlaylistResponse
	err = json.Unmarshal(jsonData, &parsedResponse)
	require.NoError(t, err)

	// Verify data integrity
	assert.Equal(t, originalResponse.PlaylistName, parsedResponse.PlaylistName)
	assert.Equal(t, originalResponse.Description, parsedResponse.Description)
	assert.Len(t, parsedResponse.Songs, 1)

	song := parsedResponse.Songs[0]
	assert.Equal(t, "Test Artist", song.Artist)
	assert.Equal(t, "Test Song", song.Title)
	assert.Equal(t, "Test Album", song.Album)
	assert.Equal(t, 2023, song.Year)
	assert.Equal(t, "Test reason", song.Reason)
}

func TestSong_OptionalFields(t *testing.T) {
	// Test that songs work with minimal data
	song := Song{
		Artist: "Test Artist",
		Title:  "Test Song",
	}

	jsonData, err := json.Marshal(song)
	require.NoError(t, err)

	var parsedSong Song
	err = json.Unmarshal(jsonData, &parsedSong)
	require.NoError(t, err)

	assert.Equal(t, "Test Artist", parsedSong.Artist)
	assert.Equal(t, "Test Song", parsedSong.Title)
	assert.Empty(t, parsedSong.Album)
	assert.Zero(t, parsedSong.Year)
	assert.Empty(t, parsedSong.Reason)
}

// Helper function to create temporary test files
func createTempFile(t *testing.T, name, content string) string {
	tmpDir := t.TempDir()
	filePath := filepath.Join(tmpDir, name)

	err := os.WriteFile(filePath, []byte(content), 0644)
	require.NoError(t, err)

	return filePath
}

// Benchmark tests for file parsing performance
func BenchmarkLoadPlaylistFromFile(b *testing.B) {
	// Create a large test file
	var lines []string
	for i := 0; i < 1000; i++ {
		lines = append(lines, "Artist "+string(rune(i%26+65))+" - Song "+string(rune(i%26+65)))
	}
	content := strings.Join(lines, "\n")

	tmpFile := filepath.Join(b.TempDir(), "benchmark.txt")
	err := os.WriteFile(tmpFile, []byte(content), 0644)
	require.NoError(b, err)

	service := NewService("test-key")

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := service.LoadPlaylistFromFile(tmpFile, "Benchmark")
		require.NoError(b, err)
	}
}
